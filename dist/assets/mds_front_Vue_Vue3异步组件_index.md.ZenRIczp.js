import{_ as s,c as i,o as a,U as n}from"./chunks/framework.hWf9kaa6.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"mds/front/Vue/Vue3异步组件/index.md","filePath":"mds/front/Vue/Vue3异步组件/index.md","lastUpdated":1704782344000}'),t={name:"mds/front/Vue/Vue3异步组件/index.md"},e=n(`<p>在大型Vue项目中，<code>defineAsyncComponent</code> 可以用来有效地处理和优化异步组件的加载。异步组件是指那些不会随着主应用立即加载，而是在需要时才加载的组件。这对于提高应用性能，特别是初始加载时间（首屏时间）非常有帮助。以下是在大型项目中使用异步组件的一些实践方案：</p><h3 id="_1-路由级别的懒加载" tabindex="-1">1. <strong>路由级别的懒加载</strong> <a class="header-anchor" href="#_1-路由级别的懒加载" aria-label="Permalink to &quot;1. **路由级别的懒加载**&quot;">​</a></h3><p>在使用Vue Router时，可以为每个路由定义异步组件。这意味着该路由的组件只有在该路由被访问时才会加载。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Home</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineAsyncComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./components/Home.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    { path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: Home }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 其他路由...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="_2-组件级别的懒加载" tabindex="-1">2. <strong>组件级别的懒加载</strong> <a class="header-anchor" href="#_2-组件级别的懒加载" aria-label="Permalink to &quot;2. **组件级别的懒加载**&quot;">​</a></h3><p>对于那些在页面中较晚显示的组件（如模态框、提示框等），可以将它们作为异步组件来定义，从而避免在页面初始加载时加载这些组件。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { defineAsyncComponent } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LazyModal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineAsyncComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./components/LazyModal.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><h3 id="_3-使用加载状态" tabindex="-1">3. <strong>使用加载状态</strong> <a class="header-anchor" href="#_3-使用加载状态" aria-label="Permalink to &quot;3. **使用加载状态**&quot;">​</a></h3><p><code>defineAsyncComponent</code> 允许你指定加载、错误和超时状态的处理方式。这对于提供良好的用户体验非常重要。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AsyncComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineAsyncComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  loader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./MyComponent.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  loadingComponent: LoadingComponent,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  errorComponent: ErrorComponent,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  delay: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  timeout: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="_4-组合异步组件和suspense" tabindex="-1">4. <strong>组合异步组件和Suspense</strong> <a class="header-anchor" href="#_4-组合异步组件和suspense" aria-label="Permalink to &quot;4. **组合异步组件和Suspense**&quot;">​</a></h3><p>Vue 3 引入了 <code>&lt;Suspense&gt;</code> 组件，它可以与异步组件一起使用，以提供更丰富的异步处理方式，例如在加载异步组件时显示回退内容。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Suspense</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> #default&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    &lt;AsyncComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> #fallback&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    &lt;div&gt;Loading...&lt;/div&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  &lt;/template&gt;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">&lt;/Suspense&gt;</span></span></code></pre></div><h3 id="_5-分割点的选择" tabindex="-1">5. <strong>分割点的选择</strong> <a class="header-anchor" href="#_5-分割点的选择" aria-label="Permalink to &quot;5. **分割点的选择**&quot;">​</a></h3><p>确定何时使用异步组件是一个重要的决策。通常，那些大型的、不经常使用的、或可选的功能模块适合做成异步组件。</p><h3 id="_6-代码分割和打包" tabindex="-1">6. <strong>代码分割和打包</strong> <a class="header-anchor" href="#_6-代码分割和打包" aria-label="Permalink to &quot;6. **代码分割和打包**&quot;">​</a></h3><p>在构建过程中，通过Webpack的代码分割特性，可以将异步组件打包成独立的文件。这样，只有在用户需要时才会加载这些文件。</p><h3 id="_7-监控和优化" tabindex="-1">7. <strong>监控和优化</strong> <a class="header-anchor" href="#_7-监控和优化" aria-label="Permalink to &quot;7. **监控和优化**&quot;">​</a></h3><p>持续监控应用的性能，特别是异步加载的部分。根据用户的实际使用情况和反馈来调整和优化异步加载策略。</p><h3 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h3><p>在大型Vue项目中，合理利用 <code>defineAsyncComponent</code> 可以显著提升应用的性能，特别是对首屏加载时间的优化。同时，为了提供良好的用户体验，应当注意异步加载时的反馈（如加载指示器）、错误处理和性能监控。</p>`,21),l=[e];function h(p,k,r,d,o,E){return a(),i("div",null,l)}const y=s(t,[["render",h]]);export{c as __pageData,y as default};
